name: Kaggle Notebook Executor - V3 Final

on:
  workflow_dispatch:
  repository_dispatch:
    types: [cron-trigger]

jobs:
  execute-notebooks:
    runs-runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        pip install kaggle
    
    - name: Execute notebooks
      run: |
        python << 'PYEOF'
        import os
        import subprocess
        import json
        import sys
        from datetime import datetime
        import shutil
        import time

        # ========================================
        # REDIS POOL (10 instances)
        # ========================================
        REDIS_POOL = [
            ("https://fair-drake-18300.upstash.io", "AUd8AAIncDE4ZGIzNjkzNjk0N2I0MDZhYjQzNWI4ZmQzMTIxZmViNnAxMTgzMDA"),
            ("https://learning-alpaca-18314.upstash.io", "AUeKAAIncDFkMmU5NTUxNTQwZWU0NjkwYmYwYjFlYmExYzE3YmUwNHAxMTgzMTQ"),
            ("https://moved-grouper-18341.upstash.io", "AUelAAIncDFiODAzNDQ4ZjY5YTE0YThhODg0NzEwZTNiOWI4OGFkZXAxMTgzNDE"),
            ("https://ace-spaniel-18358.upstash.io", "AUe2AAIncDFlNjA3NjY2MWUzMGI0MDc3YWM3NWIyZDY4OTE5MDAzYXAxMTgzNTg"),
            ("https://wondrous-lab-18392.upstash.io", "AUfYAAIncDE0YmY3MWZmYmY1MmU0NzdmYTg2MzM0ODk1MzdiMjIxMXAxMTgzOTI"),
            ("https://native-lamprey-11246.upstash.io", "ASvuAAIncDIwMjZhNjljYTQwMGM0MDM5OGE3ZWFlMDZiNGNjYWYyMnAyMTEyNDY"),
            ("https://harmless-humpback-11251.upstash.io", "ASvzAAIncDI1ZDM4ZmU3YTY4NDE0NDE1YmUxYzY1NjQzNTk5Yjg1YnAyMTEyNTE"),
            ("https://game-gobbler-11253.upstash.io", "ASv1AAIncDIwM2VmMjI0ODNhNWQ0NjYwOTgxMDU4ZDMxMGRlZDFhNHAyMTEyNTM"),
            ("https://fond-doberman-11259.upstash.io", "ASv7AAIncDJmZThiNzIwNGQ0ZWM0NzE0ODA3YzAxODY0NWEzNGM4Y3AyMTEyNTk"),
            ("https://absolute-redfish-9172.upstash.io", "ASPUAAImcDE1MzBmZjIxMGNkYzY0YzBmYjFkZTNlZmE4NzY1ZjlhN3AxOTE3Mg")
        ]

        # ========================================
        # WEEKLY SCHEDULE
        # ========================================
        WEEKLY_SCHEDULE = {
            "Friday": [
                {"username": "shreevathsaz", "key": "2faa3199cb4f8a0d88a8999604ac6770"},
                {"username": "shreevathsamm", "key": "613f3e396b629b0df65e65e35fe7b243"}
            ],
            "Saturday": [
                {"username": "vathsam", "key": "f50456cea220739ad0ecb651e79593bd"},
                {"username": "svproeditor", "key": "dee169dffee0cc31fffe2a30a4bb01a8"}
            ],
            "Sunday": [
                {"username": "yamanya", "key": "6a8da12facf5fbcc820cd00baa788a99"},
                {"username": "yamunappacom", "key": "d34212355d722ee3c75b8b6e06e2ce87"}
            ],
            "Monday": [
                {"username": "vaishakha98", "key": "4240e8c91b5cd8537de55bad47554b5e"},
                {"username": "riocom", "key": "79898aeec842d5ef19dd7acbd0c7f356"}
            ],
            "Tuesday": [
                {"username": "leommmmm", "key": "c88472f292e5de46c97952906d79c896"}
            ],
            "Wednesday": [],
            "Thursday": []
        }

        # ========================================
        # HELPER FUNCTIONS
        # ========================================
        def log(msg, symbol="‚ÑπÔ∏è"):
            timestamp = datetime.utcnow().strftime('%H:%M:%S')
            print(f"[{timestamp}] {symbol} {msg}")
            sys.stdout.flush()

        def setup_kaggle_auth(account):
            kaggle_dir = os.path.join(os.path.expanduser("~"), ".kaggle")
            os.makedirs(kaggle_dir, exist_ok=True)
            kaggle_json = os.path.join(kaggle_dir, "kaggle.json")
            with open(kaggle_json, 'w') as f:
                json.dump({"username": account["username"], "key": account["key"]}, f)
            os.chmod(kaggle_json, 0o600)
            log(f"Auth set: {account['username']}", "üîë")

        def run_cmd(cmd, timeout=180, cwd=None):
            try:
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout, cwd=cwd)
                return result.returncode == 0, result.stdout, result.stderr
            except subprocess.TimeoutExpired:
                return False, "", "Timeout"
            except Exception as e:
                return False, "", str(e)

        def inject_redis_credentials_text(notebook_path, redis_url, redis_token):
            with open(notebook_path, 'r', encoding='utf-8') as f:
                notebook_text = f.read()
            
            notebook_text = notebook_text.replace(
                'https://absolute-redfish-9172.upstash.io',
                redis_url
            )
            notebook_text = notebook_text.replace(
                'ASPUAAImcDE1MzBmZjIxMGNkYzY0YzBmYjFkZTNlZmE4NzY1ZjlhN3AxOTE3Mg',
                redis_token
            )
            
            with open(notebook_path, 'w', encoding='utf-8') as f:
                f.write(notebook_text)
            return True

        def execute_notebook(account, notebook_name, dest_slug, redis_url, redis_token):
            log(f"START: {notebook_name} ‚Üí {account['username']}", "üöÄ")
            base_dir = os.getcwd()
            work_dir = os.path.join(base_dir, f"work_{notebook_name}_{account['username']}")
            
            try:
                if os.path.exists(work_dir):
                    shutil.rmtree(work_dir)
                os.makedirs(work_dir)
                
                base_notebook_path = os.path.join(base_dir, "server-5.ipynb")
                if not os.path.exists(base_notebook_path):
                    log(f"ERROR: server-5.ipynb not found!", "‚ùå")
                    return False
                
                work_notebook_path = os.path.join(work_dir, f"{notebook_name}.ipynb")
                shutil.copy(base_notebook_path, work_notebook_path)
                
                inject_redis_credentials_text(work_notebook_path, redis_url, redis_token)
                
                metadata = {
                    "id": dest_slug,
                    "title": notebook_name,
                    "code_file": f"{notebook_name}.ipynb",
                    "language": "python",
                    "kernel_type": "notebook",
                    "is_private": True,
                    "enable_gpu": True,
                    "enable_internet": True,
                    "enable_tpu": False,
                    "dataset_sources": [],
                    "kernel_sources": [],
                    "competition_sources": []
                }
                
                metadata_path = os.path.join(work_dir, "kernel-metadata.json")
                with open(metadata_path, 'w', encoding='utf-8') as f:
                    json.dump(metadata, f, indent=2)
                
                setup_kaggle_auth(account)
                time.sleep(0.3)
                
                success, stdout, stderr = run_cmd("kaggle kernels push", timeout=240, cwd=work_dir)
                
                if not success:
                    log(f"PUSH FAILED: {stderr[:500]}", "‚ùå")
                    return False
                
                log(f"Push OK: {notebook_name}", "‚úÖ")
                return True
                
            except Exception as e:
                log(f"EXCEPTION: {str(e)}", "‚ùå")
                return False
            finally:
                if os.path.exists(work_dir):
                    shutil.rmtree(work_dir)

        # ========================================
        # PARALLEL EXECUTION
        # ========================================
        from concurrent.futures import ThreadPoolExecutor, as_completed
        
        def execute_notebook_wrapper(args):
            account, notebook_name, dest_slug, redis_url, redis_token, start_delay = args
            if start_delay > 0:
                time.sleep(start_delay)
            result_key = f"{account['username']}/{notebook_name}"
            success = execute_notebook(account, notebook_name, dest_slug, redis_url, redis_token)
            return (result_key, success)
        
        def execute_all():
            start = datetime.utcnow()
            current_day = datetime.utcnow().strftime('%A')
            
            if current_day not in WEEKLY_SCHEDULE or not WEEKLY_SCHEDULE[current_day]:
                log(f"No tasks for {current_day}", "‚è≠Ô∏è")
                return

            accounts_today = WEEKLY_SCHEDULE[current_day]
            day_order = ["Friday", "Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday"]
            redis_index = (day_order.index(current_day) * 4)
            
            tasks = []
            task_index = 0
            for account in accounts_today:
                for notebook_name in ["server-1", "server-2"]:
                    dest_slug = f"{account['username']}/{notebook_name}"
                    redis_url, redis_token = REDIS_POOL[redis_index % len(REDIS_POOL)]
                    tasks.append((account, notebook_name, dest_slug, redis_url, redis_token, task_index * 2))
                    redis_index += 1
                    task_index += 1
            
            results = {}
            with ThreadPoolExecutor(max_workers=len(tasks)) as executor:
                futures = [executor.submit(execute_notebook_wrapper, t) for t in tasks]
                for f in as_completed(futures):
                    res_key, success = f.result()
                    results[res_key] = success
            
            success_count = sum(results.values())
            log(f"SUMMARY: {success_count}/{len(results)} successful", "üèÅ")
            if success_count < len(results):
                sys.exit(1)

        execute_all()
        PYEOF
